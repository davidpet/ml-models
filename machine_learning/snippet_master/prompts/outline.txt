I. Variables
  A.  Interning
  B.  Data Types
  C.  Different Integer Type Sizes
  D.  Different Floating Point Type Sizes
  E.  Float Equality (approximate)
  F.  Constants/Final Variables
  G.  Statics
  H.  Enums (inc. most basic/minimal, numeric, string, and strongly-typed)
  I.  Nullability
  J.  NaN, Infinity, etc.
  K.  References and Mutability
  L.  Type Inference
  M.  Equality (all ways)
  N.  Casting & Coercion
  O.  Type Alias
  P.  Type Union
  Q.  Variable Lifetime inc. Caveats
  R.  Scope and Visibility
  S.  Local, Instance, and Class Variables
  T.  Pointers, References, Smart Pointers, Memory Management
  U.  Garbage Collection, Memory Leaks
  V.  Move, Copy, and Clone Semantics
  W.  Uninitialized/Default Values (inc. local, global, instance, and static contexts)

II. Operators
  A.  All Math & Logic Operators
  B.  Save Navigation
  C.  Coalescing
  D.  Comparison
  E.  Assignment
  F.  String Concatenation
  G.  Reflection
  H.  Bitwise
  I.  Boolean Operators on Non-Boolean Values
  J.  Operator Precedence
  K.  Collection Operators
  L.  String Operators
  M.  Runtime Type/Type Equality/Type Comparison

III. Strings and Printing
  A.  All Ways to Quote Strings
  B.  Character Types and Quoting
  C.  Formatted and Template Strings
  D.  String Methods
  E.  String Concatenation
  F.  Conversions To/From String
  G.  Encodings
  H.  Printing
  I.  Logging
  J.  Regular Expressions
  K.  Serialization
  L.  StringBuilder/StringBuffer/etc.
  M. Index Operator and Slicing

IV. Control Flow
  A.  if/then statements
  B.  if/then/else statements
  C.  switch statements
  D.  Switch Statements on Non-Integer Types (string, enum, custom)
  E.  for loops
  F.  while loops
  G.  do-while loops
  H.  break and continue
  I.  try/catch/finally and throwing exceptions
  J.  emptiness checks
  K.  context management
  L.  Context Management with Multiple Resources at Once
  M.  asserts
  N.  when braces are required vs. optional
  O.  Generator/Lazy List
  P.  Arguments to main() function
  Q.  Truthiness of Different Data Types in Boolean Conditions
  R.  Actual Value Returned by Short-Circuiting

V. Functions
  A.  Basic Syntax
  B.  Positional Arguments
  C.  Named Arguments
  D.  Optional/Default Arguments
  E.  Variadic Functions
  F.  Overloading
  G.  Lambdas
  H.  Nested Functions
  I.  Spread Operator
  J.  Return Type Inference
  K.  Higher-Order Functions
  L.  Inline Functions
  M.  Macros
  N.  Extension Methods

VI. Functional Programming
  A.  Lambdas
  B.  Closures (ref vs. value)
  C.  Ignored Parameters
  D.  Partial Application
  E.  Bound vs. Unbound (eg. 'this')
  F.  Declaration of Variable Holding Function
  G.  map, reduce, and filter
  H.  Return Object from Lambda

VII. Classes
  A.  Basic Syntax and Instantiation (inc. static, instance, class members, etc.)
  B.  Static Classes
  C.  Static Constructor
  D.  Access Modifiers
  E.  Inheritance
  F.  Interfaces and Abstract Base Classes
  G.  Multiple Inheritance
  H.  Polymorphism
  I.  Nullability of Class Members
  J.  Initializing Instance Values in Class Declarations
  K.  Constructors, Initialization Lists
  L.  Base and Delegating Constructors
  M.  Constructors Included by Default
  N.  Calling Base Class Method from Derived Class Method
  O.  this/self Keyword
  P.  Name Hiding
  Q.  Construction Order
  R.  Nested Classes
  S.  Dynamic Types
  T.  Operator Overloading
  U.  Indexers
  V.  Copying/Cloning
  W.  Boxing/Unboxing
  X.  Root Class of Type System (and methods to override)
  Y.  Useful Built-in Interfaces and Abstract Base Classes
  Z.  Importance of Declaration Order/Forward Declarations
  AA.  Structural typing
  AB.  Partial Classes
  AC.  Reference Type vs. Value Type
  AD.  Properties (manual and auto-implemented)
  AE.  Return Type Inference
  AF.  Destructors/Finalizers/Disposable Pattern
  AG.  Callable Object/Call Operator
  AH.  Anonymous Class

VIII. Generics/Templates
  A.  Generic Function
  B.  Explicitly Calling Generic Function with Type
  B.  Generic Class
  B.  Explicitly Creating Generic Class with Type
  C.  Generic Lambda
  D.  Important Built-in Generic Classes/Interfaces
  E.  Void as T argument
  F.  Metaprogramming
  G.  Type Erasure/Runtime Type
  H.  Type Constraints
  I.  Type Wildcards

IX. Modules/Packages/Imports
  A.  Importing Built-In Libraries
  B.  Declaring Importable Module/Package
  C.  Importing Custom Module/Package by Relative path from Subfolder
  D.  Other Package Management Options
  E.  Renaming Imported Symbols
  F.  Wrapping Multiple Imported Symbols
  G.  Exporting and Access levels
  H.  Multiple Imports on One Line
  I.  Barrelling
  J.  Statefulness of Imported Packages
  K.  Namespaces
  L.  Ambient Declarations
  M.  Search Path
  N.  Importing Constants and Variables
  O.  Default Imports in Every Program
  P.  Multiple Top-Level Classes in Same File
  Q.  Top-Level Classes Referring to Each Other Mutually
  R.  Top-Level Functions (not in classes)
  S.  Top-Level Variables/Constants (not in classes)
  T.  Top-Level Enums (not in classes)

X. Docstrings
  A.  Functions
  B.  Classes
  C.  Variables
  D.  Package/File

XI. Decorators
  A.  Function Decorators
  B.  Class Decorators
  C.  Useful Built-In Decorators

XII. Collections
  A.  Array
  B.  List
  C.  Vector
  D.  Dictionary/Map
  E.  Set
  F.  String Builder
  G.  Tuple
  H.  Struct
  I.  Immutable Types
  J.  String as Collection
  K.  Generic Sequence/Iterable Type
  L.  Aggregate functions (max, min, etc.)
  M.  Iterating Keys vs. Values
  N.  Zipping
  O.  Slicing
  P.  Sorting
  Q.  Stack and Queue
  R.  Collection Literals and Inline Initialization
  S.  Builder Pattern
  T.  Index Operator
  U.  Conversions Between Collection Types

XIII. Standard library
  A.  Console I/O
  B.  Math
  C.  File I/O
  D.  Threading/async/await/lock/promise
  E.  HTTP
  F.  Paths and Environment Variables

XIV. Testing (JUnit-style)
  A.  Test Class/Suite and Methods
  B.  Setup and Teardown
  C.  Persistence of Class/Suite Data Between Tests
  D.  Asserts
  E.  Mocking
  F.  Faking
  G.  Screendiffs
